## 类

### 类的定义

```js
class Person {
  name: string = ''
  showName(): void {
    console.log(this.name)
  }
}
let p = new Person()
p.name = 'xiaoqiang'
p.showName()
```

### 继承

```js
class Parent {
  surname: string = 'li'
  name: string
  age: number
  constuctor(name: string, age: number) {
    this.name = name
    this.age = age
  }
  coding() {
    console.log('写代码')
  }
  showName() {
    console.log(this.name, this.age)
  }
}
class Child extends Parent {
  constructor(name: string, age: number) {
    super()
    this.name = name
    this.age = age
  }
  playBasketball() {
    console.log('打篮球')
  }
}

let c = new Child('xiaoli', 20)
c.showName()
```

### 成员修饰符

```js
public 公有属性, ts中成员默认是public，即可以自由访问的
private 私有属性，类外部是不能访问这个属性的
protected 受保护的属性，和private类似，外部不能访问，但是可以在子类中使用
```

```js

class Parent {
  surname: string = "li"
  private _name: string = "li lei"
  coding() {
    console.log("写代码")
  }
}
let p = new Parent()
// 访问私有属性报错
console.log(p._name)
```

```js

class Parent {
  protected surname: string = "li"
  private _name: string = "li lei"
  coding() {
    console.log("写代码")
  }
}

class Child extends Parent {
  playBasketball() {
    console.log("打篮球")
  }
  showName() {
    console.log(this.surname)
  }
}

let p = new Parent()
let c = new Child()

// console.log(p.surname)  外部不能访问
// 子类里面可以使用 surname
c.showName()

```

### 存取器

```js
let passcode = "secret passcode"

class Employee {
  private _fullName: string

  get fullName(): string {
    return this._fullName
  }

  set fullName(newName: string) {
    if (passcode && passcode == "secret passcode") {
      this._fullName = newName
    } else {
      console.log("Error: Unauthorized update of employee!")
    }
  }
}

let employee = new Employee()
employee.fullName = "Bob Smith"
if (employee.fullName) {
  console.log(employee.fullName)
}
```

### 只读属性

一个属性只可以读取，不可以修改

```js
class Animal {
  readonly name: string = "xiaogou"
}
let dog = new Animal()
// 不能设置  注意：这里只是类型检查的时候报错，但是编译后还是可以正常设置
// dog.name = "xiaoqiang"
console.log(dog.name)

```

### 参数属性

如果只读属性需要在创建对象的时候传参来初始化，需要在构造函数里面进行

```js

class Animal {
  readonly name: string
  constructor(uname: string) {
    this.name = uname
  }
}
let dog = new Animal("xiaogou")

console.log(dog.name)

```

参数属性可以帮助我们简化上面的代码，直接把只读属性放到构造函数的参数中即可

```js
class Animal {
  constructor(readonly name: string) {}
}
let dog = new Animal("xiaogou")

console.log(dog.name)
```

### 静态属性和静态方法

静态属性和静态方法就是不需要创建类的实例，可以直接调用的属性和方法

```js
class Person {
  static cname: string = 'xiaoqiang'
  static showName(): string {
    return this.cname
  }
}
console.log(Person.cname)
console.log(Person.showName())
```

### 抽象类

抽象是从众多的事物中抽取出共同的、本质性的特征，抽象类它首先是一个类，它和普通类的区别在于它提取了些共同的、本质的特征，可以用来定义一些标准，抽象类是不能被实例化的，通常它是作为派生类的基类在使用，这个和接口是不同的，等我们讲了接口以后再来对比差异

```js
// 使用abstract定义抽象类
abstract class Person {}
// 这里报错，抽象类无法被实例化
let p = new Person()
```

抽象类定义了标准，需要在子类中去实现

```js
abstract class Person {
  name: string
  abstract showName(): string
}

class Man extends Person {
  name = 'xiaoqiang'
  showName(): string {
    return this.name
  }
}

let p = new Man()
console.log(p.showName())
```

注意 1：抽象类中的抽象方法也要使用 abstract 关键字

注意 2:抽象类的子类必须实现抽象类的抽象方法，不然会报错

```js
abstract class Person {
  name: string
  abstract showName(): string
}

class Man extends Person {
  name = 'xiaoqiang'

}

```

注意 3:抽象类中可以放普通方法

```js
abstract class Person {
  name: string
  abstract showName(): string
  showAge(): void {
    console.log(111)
  }
}

class Man extends Person {
  name = 'xiaoqiang'
  showName(): string {
    return this.name
  }
}

let p = new Man()
console.log(p.showName())
```
