## 接口

### 什么是接口

接口用于定义规范，为你的代码定义契约，和现实中的 USB 接口、Type-C 接口等一致,

### 接口的应用场景

假如有一个函数，接收一个 config 对象，然后返回 config 里面的配置

```js
const getHostName = (config) => config.hostname
```

如果直接这样写，config 就是一个隐式的 any 类型，这在我们的配置里面是不允许的，因此，我们需要给这个 config 定义一个类型，但是这个 config 并不是我们的基本类型，所以我们需要使用接口来描述这个 config 的类型

我们定义一个 config 的接口

```js
interface Config {
  hostname: string
  port: number
}
const getHostName = (config: Config) => config.hostname
```

这样，我们就可以正常的调用函数了

```js
console.log(getHostName({ hostname: 'localhost', port: 8080 }))
```

如果不按照接口的规范来传参数，就会报错，例如：

```js
console.log(getHostName({ hostname: 'localhost', port: 8080, base: '/' })) // 报错
```

### 可选属性

有些时候，某些属性是可选的，比如 port 这个属性，假如不传就使用默认配置，这个时候，就需要将 port 这个属性设置成可选属性才行

```js
interface Config {
  hostname: string
  port?: number
}
const getHostName = (config: Config) => config.hostname

console.log(getHostName({ hostname: 'localhost' }))

```

### 只读属性

有些场景下，属性是不能修改的，比如 root 用户名，我们不允许修改，这个时候我们就要用到只读属性，我们的接口可以这样来描述

```js
interface Config {
  hostname: string
  port?: number
  readonly root: string
}
const getHostName = (config: Config) => (config.root = 'admin')

console.log(getHostName({ hostname: 'localhost', root: 'root' }))

```

### 函数类型

接口中是可以包含函数类型的，我们可以这样定义

```js
interface Config {
  hostname: string
  port?: number
  readonly root: string,
  callback: (name:string)=>string
}
const getHostName = (config: Config) => config.root

console.log(getHostName({ hostname: 'localhost', root: 'root' ,callback: (name:string)=>name}))

```

### 额外属性检查

传入的属性比接口定义的属性多的时候，会进行额外的属性检查,比如这种：

```js
interface Config {
  hostname: string
  port?: number
  readonly root: string
}
const getHostName = (config: Config) => config.root

console.log(
  getHostName({
    hostname: 'localhost',
    root: 'root',
    callback: (name: string) => name
  })
)

```

callback 多传了，会报错

再比如，下面的代码：

```js
interface Config {
  hostname: string
  port?: number
  readonly root: string
}
const getHostName = (config: Config) => config.root

console.log(
  getHostName({
    hostname: 'localhost',
    root: 'root',
    part: 9090
  })
)

```

port 误操作写成了 part，这个时候也会进行额外的类型检查，抛出错误，一般抛出错误的时候，你都要去查看当前到底是误操作还是本身就支持这些额外的属性，如果确定是支持的额外属性，你可以通过以下方式来解决报错问题：

第一，使用类型断言的方式

```js
interface Config {
  hostname: string
  port?: number
  readonly root: string
}
const getHostName = (config: Config) => config.root

console.log(
  getHostName({
    hostname: 'localhost',
    root: 'root',
    part: 9090
  } as Config)
)
```

第二种，添加字符串索引签名

```js
interface Config {
  hostname: string
  port?: number
  readonly root: string
  [propName: string]: any
}
const getHostName = (config: Config) => config.root

console.log(
  getHostName({
    hostname: 'localhost',
    root: 'root',
    part: 9090
  })
)
```

第三种，把对象字面量赋值给另一个参数

```js
interface Config {
  hostname: string
  port?: number
  readonly root: string
  [propName: string]: any
}
const getHostName = (config: Config) => config.root
let conf = {
  hostname: 'localhost',
  root: 'root',
  part: 9090
}
console.log(getHostName(conf))

```

### 可索引类型

假如说 Config 里面有一条配置，专门用来引入插件的，这些插件是一个集合，集合中到底用了哪些插件是不确定的，这个时候我们可以使用可索引类型来描述

```js
interface Plugins {
  [name: string]: string
}
interface Config {
  hostname: string
  port?: number
  readonly root: string
  [propName: string]: any
  plugins?: Plugins
}
const getHostName = (config: Config) => config.root
let conf = {
  hostname: 'localhost',
  root: 'root',
  part: 9090
}
console.log(getHostName(conf))

```

### 接口继承

假如有个基础的配置对象，在这个基础的配置对象上会增加一个新属性形成一个生产环境的配置，这个时候，我们生产环境的配置就可以继承基础配置

```js
interface baseConfig {
  hostname: string
  port?: number
  readonly root: string
}
interface Plugins {
  [name: string]: string
}
interface Config extends baseConfig {
  env: string
  plugins?: Plugins
}
const getHostName = (config: Config) => config.root
let conf = {
  hostname: 'localhost',
  root: 'root',
  part: 9090,
  env: 'dev'
}
console.log(getHostName(conf))

```
