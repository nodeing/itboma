## 泛型

### 什么是泛型

泛型从字面上理解，关键字就是这个 泛，广泛的意思，结合起来就是广泛的类型，怎样才能表示广泛的类型呢，方法很简单，搞一个变量来存储类型就行了，所以泛型在 TypeScript 中实际上就是一个类型变量，下面我们来看它的应用场景

假设有一个函数，传入一个数字，原封不动的返回一个数字，函数可以写成这样

```js
let fn = (num: number): number => num
```

如果把需求改成，传入一个字符串，返回的就是一个字符串，函数变成这样：

```js
let fn = (str: string): string => str
```

以此类推，如果我们想让它实现传入的是什么类型的值，就返回什么类型的值，这个时候函数应该怎么写呢？

```js
let fn = <T>(str: T): T => str
console.log(fn(1))
console.log(fn('1'))
console.log(fn(true))
```

上面代码中的 T 就是类型变量，总结，定义：泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性

### 多个类型参数

可以一次定义多个类型参数

```js
let fn = <T, U>(tuple: [T, U]): [T, U] => {
  return [tuple[0], tuple[1]]
}
console.log(fn([1, '999']))
```

### 泛型变量的使用

```js
let fn = <T>(arg: T): void => {
  console.log(arg)
}
```

上面我们定义了一个泛型变量 T 和参数 arg，这个时候 T 的类型是由 arg 传入值决定的，如果我们要操作 arg 参数，例如：取 arg 的长度

```js
let fn = <T>(arg: T): void => {
  console.log(arg.length)
}
```

这个时候编译会报错，因为 arg 是可以传入任意类型的，编译器并不知道 arg 到底是什么类型，假如：arg 是一个数字，那么它身上就没有 length 这个属性，因此，这样使用是会有问题的，如果我们一定要取 arg 的长度，这个时候，我们可以将 arg 的类型定义成数组，写成 T[]

```js
let fn = <T>(arg: T[]): void => {
  console.log(arg.length)
}
```

把 arg 设置成类型 T 的数组，这样我们就把 T 作为了数组类型的一部分使用，也是比较灵活的，你传入的是数字类型的数组，T 就是数字类型，传入的是字符串类型的数组，T 就是字符串类型

泛型变量使用注意：

::: tip
不是所有类型都能做的操作不能做，不是所有类型都能调用的方法不能调用
:::

### 泛型函数类型

我们可以先定义一个泛型函数，然后把这个函数作为类型使用，这就是泛型函数类型

```js
type Fn = <T>(arg: T) => T

let fn: Fn = (arg) => {
  console.log(arg)
  return arg
}
```

简写：

```js
let fn: <T>(arg: T) => T = (arg) => arg
```

### 泛型接口

定义一个泛型接口

```js
interface User {
  <T>(uname: T): T;
}
let user: User = (uname) => uname
console.log(user('xiaohong'))
```

我们可以把接口里面的泛型变量拿出来，作为接口的参数传入

```js
interface User<T> {
  (uname: T): T;
}
let user: User<string> = (uname) => uname
console.log(user('xiaohong'))
```

这样做的好处就是我们可以在使用接口的时候传参数，比较灵活，其他的成员也可以使用这个参数类型

### 泛型类

普通类

```js
class Person {
  constructor(readonly cname: string) {}
  showname: (uname: string) => string = uname => {
    return uname
  }
}

let p = new Person('xiaoli')
console.log(p.cname)
console.log(p.showname('xiaohei'))

```

泛型类：

```js
class Person<T> {
  constructor(readonly cname: T) {}
  showname: (uname: T) => T = uname => {
    return uname
  }
}

let p = new Person('xiaoli')
console.log(p.cname)
console.log(p.showname('xiaohei'))

```

### 泛型约束

泛型可以代表任意类型，这个范围比较广，但是如果我们明确知道了传入的类型就是 number 或者 string 中的一种，就需要对泛型进行约束，说白了就是缩小范围

使用 extends 关键字对泛型进行约束

```js
type Params = string | number
let fn = <T extends Params>(arg: T): T => {
  return arg
}

fn('1')
fn(1)
fn(true) // 报错

```

```js
interface Params {
  length: number
}
let fn = <T extends Params>(arg: T): void => {
  console.log(arg.length)
}
```

```js
// keyof 是一个索引类型查询器，举例：
interface Person {
  username: string
  age: number
}
type k = keyof Person

//上面代码只用于说明keyof的用法


function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key]
}

let obj = { a: 1, b: '2', c: 3 }
getProperty(obj, 'a')
getProperty(obj, 'b')
getProperty(obj, 'x') // 报错

```
