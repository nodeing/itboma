## 语法细节(3)

### 类型保护

类型保护指的是允许你使用更小范围下的类型对象

举个例子：

```ts
function fn(a: string | number) {
  console.log(a.length)
}
```

上面代码，会得到如下提示

![20221117203107](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117203107.png)

如何解决这个问题呢？ 我们可以使用类型断言

```ts
function fn(a: string | number) {
  console.log((a as string).length)
}
```

此时，类型检查通过，不会出现错误提示

![20221117203225](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117203225.png)

这种方案并不是更好的方案，因为在使用的时候有可能会传入数字，运行的时候也会报错,一个更好的方案是做类型保护，把类型对象的范围缩小，例如：

```ts
function fn(a: string | number) {
  if (typeof a == 'string') {
    console.log(a.length)
  }
}
fn(100)
```

这样写就是我们讲的类型保护，类型保护的写法有多种

- 举个例子： instanceof

```ts
class Teacher {
  name = 'xiaoqiang'
}
class Student {
  age = 32
}
function fn(p: Teacher | Student) {
  console.log(p.name)
}
```

上面代码中，函数 fn 的参数 p 可能是两种类型中的一种，在函数体内部，如果直接使用 p.name 的话，万一我们传入的 p 是 Student 类型，那么就会出错，因此，上面的代码会得到错误提示

![20221117204102](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117204102.png)

我们可以使用 instanceof 来做类型保护,代码需要做如下改进

```ts
class Teacher {
  name = 'xiaoqiang'
}
class Student {
  age = 32
}
function fn(p: Teacher | Student) {
  if (p instanceof Teacher) {
    console.log(p.name)
  }
}
fn(new Student())
fn(new Teacher())
```

- 举个例子：in，in 操作符可以安全的检查一个对象上是否存在一个属性，它通常也被作为类型保护使用

```ts
interface Teacher {
  name: string
}
interface Student {
  age: number
}
function fn(p: Teacher | Student) {
  if ('name' in p) {
    console.log(p.name)
  }
}
let t: Teacher = {
  name: 'xiaoqiang'
}
fn(t)
```

- 举个例子： 字面量类型

```ts
type Teacher = {
  name: 'xiaoqiang'
}
type Student = {
  name: 'xiaoli'
}
function fn(p: Teacher | Student) {
  if (p.name == 'xiaoqiang') {
    console.log(p.name)
  }
}
let t: Teacher = {
  name: 'xiaoqiang'
}
fn(t)
```

- 举个例子： 自定义类型保护

```ts
function fn(a: string | number) {
  if (typeof a == 'string') {
    console.log(a)
  }
}
fn(100)
```

这是我们前面写过的代码，在我们这段代码中，if 判断的逻辑比较简单，有时候逻辑比较复杂，我们可能会把相关的逻辑抽离成单独的方法，例如：

```ts
function isString(a: any) {
  return typeof a == 'string'
}
function fn(a: string | number) {
  if (isString(a)) {
    console.log(a.length)
  }
}
fn(100)
```

上面的代码仅仅是我们把代码抽离出去封装了一个单独的方法，此时，ts 就不能做类型保护了

![20221119104229](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119104229.png)

这个时候，我们需要对封装的代码做一下改进

```ts
function isString(a: any): a is string {
  return typeof a == 'string'
}
function fn(a: string | number) {
  if (isString(a)) {
    console.log(a.length)
  }
}
fn(100)
```

我们封装的方法， 增加了一个 a is string 返回值，这样就可以做类型保护了

### 映射类型和内置工具类型

可以讲已知类型的每个属性都变为可选的或者只读的，意思就是说我们可以根据一个类型的属性映射出另一个类型

举个例子：

```ts
type A = {
  name: string
  age: number
}

type B<T> = {
  readonly [p in keyof T]: T[p]
}

type C = B<A>
```

上面代码中，我们通过 B 类型，对 A 类型做了映射，并且属性是只读的

![20221119112227](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119112227.png)

代码解读

```ts
B<T>: 这里的T是一个泛型变量
B<A>: 把类型A传给泛型变量T
keyof T: 这里得到的就是一个T类型属性的联合类型，例如： "name"|"age"
p in keyof T: 这里相当于for in循环，"name"|"age" 这里被循环出来放到p身上
T[p]: 取T类型的p属性，例如： A[p]--> A["name"] 得到 string类型

最终映射出来就是:
type B<T> = {
    readonly name: string
    readonly age: number
}
```

上面的映射类型，我们是通过自己定义的 B 类型来实现的，在 TS 中，其实已经为我们提供了很多内置的类型，不需要我们单独再去写代码实现，例如，上面我们自己实现的映射类型，就可以通过下面的代码很方便的实现

```ts
type A = {
  name: string
  age: number
}

// type B<T> = {
//    readonly [p in keyof T]: T[p]
// }

type C = Readonly<A>
```

我们使用内置的 Readonly 即可

![20221119113210](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119113210.png)

除了上面我们说的这个 Readonly，还有很多内置的类型，例如：

```
Readonly 属性只读
Partial 属性可选
Pick 筛选属性
Record 把属性指定成具体的某个类型
Required 必选项属性
Omit 和Pick操作相反，排除掉属性
```

下面来看具体的例子：

- Partial

```ts
type A = {
  name: string
  age: number
}

type C = Partial<A>
```

A 映射出来的类型 C，把属性都变成了可选的

![20221119114527](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119114527.png)

- Pick

```ts
type A = {
  name: string
  age: number
}

type C = Pick<A, 'name'>
```

上面代码中，表示从 A 类型里面，挑选属性 name，映射成 C，你把鼠标移动到 C 上面，提示如下

![20221119114739](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119114739.png)

类型 C 就只有 name 属性

- Record

```ts
type A = {
  name: string
  age: number
}

type C = Record<keyof A, string>
```

上面代码表示把 A 里面的属性都设置成 string 类型，映射到 C

![20221119115040](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119115040.png)

注意哈，A 里面的 age 原来是 number 类型，经过 Record 的映射，C 里面的 age 是 string 类型,你也可以单独映射某一个属性

```ts
type C = Record<'age', string>
```

- Required

```ts
type A = {
  name?: string
  age?: number
}

type C = Required<A>
```

Required 的意思是把原来可选的属性都映射成必选的属性

![20221119115329](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119115329.png)

可以看到 C 里面的 name 和 age 都变成了必选项

- Omit

这个和 Pick 相反

```ts
type A = {
  name?: string
  age?: number
}

type C = Omit<A, 'age'>
```

上面代码，表示排除掉 A 里面的 age 属性，剩下的映射到 C

![20221119115534](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119115534.png)

### 条件类型

条件类型指在初始条件下并不确定到底是什么类型，而是通过一定的类型运算得到最终的类型，这个和条件语句非常类似

举个例子：

```ts
type A = number
type B = string
//条件 A extends B指的是 类型A可以分配给类型B
type C = A extends B ? {} : []
```

上面代码中，条件 A extends B 不成立，所以 C 的类型是 []

![20221119150740](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119150740.png)

如果你把代码改成这样,条件就成立了

```ts
type A = number
type B = string | number
type C = A extends B ? {} : []
```

我们再来看 C 是什么类型

![20221119150859](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119150859.png)

通过上面的例子，应该能理解什么是条件类型了，其实和条件语句是一样的，不过也要注意，如果无法判断条件是否成立，返回的是联合类型，例如下面的代码

```ts
type A = any
type B = string | number
type C = A extends B ? {} : []
```

再来看看 C 的类型

![20221119151123](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119151123.png)

### extends 总结

extends 在 ts 中有以下用法

```
1.表示继承/拓展

2.表示约束

3.表示分配
```

第一种用法，子类继承父类

```ts
class A {
  showName() {
    console.log(1)
  }
}
// 子类继承父类
class B extends A {}
let b: B = new B()
b.showName()
```

第二种用法，泛型约束

```ts
function getName<T extends { name: string }>(name: T) {
  console.log(name)
}
getName({ name: 'xiaoqiang' })
```

第三种用法，分配

```ts
type A = {
  name: string
}

type B = {
  name: string
}
// A 分配给B 条件成立
type C = A extends B ? 'yes' : 'no'
```

可以看一下 C 的结果

![20221119155508](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119155508.png)

我们把代码稍微修改一下

```ts
type A = {
  name: string
}

type B = {
  name: string
  age: number
}
// A 不能分配给B，缺少 age
type C = A extends B ? 'yes' : 'no'
```

再来看 C 的结果

![20221119155640](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119155640.png)

注意分配的规律,请看下面的代码

```ts
type A = 'x' extends 'x' ? string : number // string
type B = 'x' extends 'y' ? string : number // number

type P<T> = T extends 'x' ? string : number
type C = P<'x' | 'y'> // string | number
```

上面的代码中，为什么最后 C 是 string|number 联合类型，记住下面的规律

满足两个条件

```ts
1.参数是泛型  例如：T extends 'x'，前面的T是泛型
2.传入的是联合类型 例如：P<'x' | 'y'>
```

如果满足上面的情况，你在计算的时候，就用下面的规律

第一，把联合类型的每一项代入计算，例如

```ts
// P<'x' | 'y'> 分别把"x" 和 “y”代入
// 把 "x" 代入,结果 string
type C = 'x' extends 'x' ? string : number
// 把 "y" 代入 结果 number
type C = 'y' extends 'x' ? string : number
```

第二步，把上面代入的结果组合成联合类型

所以，最终的结果就是 "string" | "number"

![20221119161912](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221119161912.png)

### 内置条件类型

内置的条件类型就是 ts 帮我们写好的一些功能，我们可以直接使用，例如：

```
Exclude 排除
Extract 和Exclude相反，留下，排除其他
NonNullable 排除null和undefined
Parameters 把函数参数转成元祖类型
ReturnType 返回值的类型
```

举个例子

- Exclude

```ts
// 从 'x' | 'y' 里 排除 ‘x’
type C = Exclude<'x' | 'y' | 'z', 'x'>
```

- Extract

```ts
// "x"|"y"|"z"  留下 "x" 排除其他
type C = Extract<'x' | 'y' | 'z', 'x'>
```

- NonNullable

```ts
// 排除null和undefined
type C = NonNullable<string | null | undefined>
```

- Parameters

```ts
type fn = (a: string, b: number) => string
// F 结果 => [a:string, b:number]
type F = Parameters<fn>
```

- ReturnType

```ts
type fn = (a: string, b: number) => string
// F 结果=> string
type F = ReturnType<fn>
```

### infer 关键字

infer 关键字表示在 extends 条件语句中待推断的类型变量。

举个例子：

```ts
type A<T> = T extends (args: infer a) => void ? a : T
```

上面这段代码中 infer a 表示待推断的类型变量，如果 T extends (args: infer a) => void 条件成立，返回这个类型变量 a，否则就返回 T，待推断的意思是需要具体传值的时候，才推断是啥类型，再来看下面的代码

```ts
type A<T> = T extends (args: infer a) => void ? a : T

interface User {
  name: string
  age: number
}
type Fn = (user: User) => void

type a1 = A<Fn> //a = User
type a2 = A<string> // a = string
```

上面代码中，

```
T extends (args: infer a) => void
```

这里用 infer 关键字定义了一个待推断的类型，当真正传入的时候,代入 Fn，就变成了

```
Fn extends (args: infer a) => void
```

其中 a 会被推断成 User 类型
