## 语法细节(2)

### unknown 类型

一般情况下，我们在写 TS 的时候，会明确具体变量的类型，例如，定义一个函数我们应该确定需要传入什么以及最后返回什么 neir，这些都是确定的,例如：

```ts
const sum = (a: number, b: number): number => a + b
```

但有时候我们并不确定用户传进来的类型，又或者说我们允许传进来任何类型，例如：

```ts
const doSomething = (val: any) => {
  val() // no error
  val.foo.bar // no error
}
```

这就是 any 的场景，any 是 ts 给出的一种妥协方案，使用了 any 就失去了类型检查的作用，该报错的地方也不会报错，让 ts 变成了 js，因此，网上有人吐槽一些水货用 ts，大量使用 any，其实还是在写 js，在 TypeScript 3.0 起就引入了一个新的基础类型 unknown 作为一个类型安全的 any 来使用，换句话理解 unknown 类似是更安全的 any 类型

举个栗子：

使用 any 类型

```ts
let a: any = 'nodeing'
a.forEach((item: any) => {
  console.log(item)
})
```

这样是不会有报错提示的

![20221117125248](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117125248.png)

如果你换成了 unknown 类型

```ts
let a: unknown = 'nodeing'
a.forEach((item: any) => {
  console.log(item)
})
```

这样写，就会做类型检查，给你一个提示

![20221117125327](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117125327.png)

既然给了提示，我们就需要明确指定一个具体的类型来使用,这就会用到我们另一个知识，类型断言

### 类型断言

类型断言就是当 ts 自动推导出来的类型无法满足你的需求的时候，你需要手动指定某个类型,使用了类型断言后，意味着你告诉 ts，你不用管类型推导了，我自己比你更清楚是什么类型

```ts
let a: unknown = 'nodeing'
a.forEach((item: any) => {
  console.log(item)
})
```

上面的代码，就需要我们使用类型断言来收窄 unknown 类型，即给 a 指定一个明确的类型，你才能使用 forEach

```ts
let a: unknown = 'hello'

;(a as []).forEach((element: any) => {
  console.log(element)
})
```

这样写就不会有错误提示了

![20221117132225](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117132225.png)

:::tip
注意：类型断言只是在编译之前让你写代码符合 ts 的类型检查，编译之后是没法控制的，该报错还是得报错，例如：我们上面的案例把 a 这个变量断言成数组，然后使用数组的 forEach 方法，但是编译之后还是会报错
:::

![20221117132529](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117132529.png)

因此，在使用类型断言的时候，你需要明确知道运行的结果，你需要对结果负责，使用类型断言需要小心谨慎点

非空断言的写法，先看一段没有使用断言的代码

```ts
let a: string | undefined = undefined

console.log(a.length)
```

此时，ts 会给出提示

![20221117133040](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117133040.png)

如果我们使用非空断言

```ts
let a: string | undefined = undefined

console.log(a!.length)
```

此时，就没有相应的提示了

![20221117133126](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117133126.png)

切记，在使用断言的时候，要小心谨慎一点

### 可调用注解

思考一个问题：如何在定义一个函数类型的时候，支持函数重载？目前，我们所学的知识点中，定义函数类型都没有涉及到重载的情况

举个例子：

```ts
type A = (a: string) => string

function fn(a: string): string {
  return '11'
}

let a: A = fn
```

上面这这段代码中，fn 符合函数类型 A 的规范，因此没有报错，如果我想让函数类型 A 在定义的时候，也支持函数重载，应该这样写

```ts
type A = {
  (a: string): string
  (a: number): number
}

function fn(a: string): string
function fn(a: number): number
function fn(a: string | number): string | number {
  return '11'
}

let f: A = fn
```

### keyof 关键字

keyof 关键字可以方便的从接口中获取到接口的 key 作为字面量类型，举个例子

```ts
interface obj {
  username: string
  age: number
}
type A = keyof obj // 等价于 type A = "username"|"age"
let p: A = 'age'
```

keyof 的应用场景

假设有一个需求，一个函数，传入 key 和 obj 对象，返回这个对象身上 key 对应的值，在 js 中我们应该这样写

```js
function fn(obj, key) {
  return obj[key]
}
```

在 ts 中，我们需要加入类型注解，代码如下

```ts
function fn(obj: object, key: any) {
  return obj[key]
}
```

此时，ts 会提示报错

![20221117194515](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117194515.png)

我们需要对代码进行改进

```ts
function fn<T extends object, K extends keyof T>(obj: T, key: K) {
  return obj[key]
}
```

上面代码中，我们定义了两个泛型变量，T 继承自 object，这意味着传入的 obj 参数只能是 object 类型，通过
"K extends keyof T" 这句代码，可以把 key 的类型约束在 obj 这个对象的 key 里面，即

```ts
let obj = {
  username: 'xiaoqiang',
  age: 18
}
// keyof obj ==> "username" | "age"
```

下面，我们再来通过具体的传参，再来理解 keyof 的使用场景

```ts
// K extends keyof T ===》 K = "id"|"username"|"age"|"gender"
function fn<T extends object, K extends keyof T>(obj: T, key: K) {
  return obj[key]
}

interface Person {
  id: number
  username: string
  age: number
  gender: string
}

let p: Person = {
  id: 1,
  username: 'xiaoqiang',
  age: 18,
  gender: '男'
}
console.log(fn(p, 'id')) // 输出结果 1
console.log(fn(p, 'age')) // 输出结果 18
console.log(fn(p, 'username')) // 输出结果 "xiaoqiang"
console.log(fn(p, 'gender')) // 输出结果 “男”
```

### 类型别名和接口的区别

区别 1

```
type 定义别名的时候，是可以使用基本类型的
interface 不能直接定义基本类型
```

举个例子

```ts
// 这样写是可以的
type A = string
// 这样写不可以
interface A string
```

区别 2

```
interface 具备自动合并的能力，而type 类型别名不支持
```

举个例子：

```ts
interface A {
  username: string
}
interface A {
  age: number
}
// A已经合并，需要同时满足username和age，否则报错
let p: A = { username: 'xiaoqiang' }
```

上面代码中，接口 A 定义了两次，合并在一起了，我们在使用的 A 接口的时候，必须同时满足 username 和 age，否则会报错

![20221117184201](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117184201.png)

type 定义类型别名的时候是不支持合并的，从语法上就会报错

![20221117184451](https://nodeing-com-1252923609.cos.ap-chengdu.myqcloud.com//document20221117184451.png)

区别 3

```
接口具备继承的能力，而类型别名不具备继承能力
```

接口继承我们在前面已经讲过，这里不做演示

区别 4

```
type 具备映射类型，接口不支持,关于映射类型，我们在后面的章节中讲
```
